Flight Kinematics

An important part of Project Icarus is turning the arm position information from the camera into virtual flight.  During the development of Project Icarus we experimented with two different flight models.  Our first attempt was a force-based flight model.  In the end, we settled upon a velocity-based approach that is not as realistic, but provides for a less frustrating experience.  We use OPAL (Open Physics Abstraction Layer) as our physics engine.  OPAL provides powerful features for simulating the application of forces and torques to a rigid body.  

All of the interacting elements in the simulation (the ground plane, boxes, and user bounding box) are represented by rectangular solids.  Each solid has a number of properties that can be set such as density, size, center of gravity, and material.  We used boxes that had a high density and materials that have no friction coefficient.  The reason for not using friction is that the user would have a tendency to tumble violently when contacting another solid.  Implementing a method for righting the user after tumbling would be useful, however, we did not have time to do this and we do not think that the user experience will suffer greatly.

Our first, force-based model was very simplistic and ad hoc.  We used three forces applied to the user solid to acheive flight.  These forces are all dependent on the normalized arm position.  The most important force for flight is what we have termed the buoyant force.  The buoyant force must increase when the arms are extended, but not exceed the force of gravity to simulate soaring.  Also, the buoyant force must be greater than the force of gravity when the arms are flapping to simulate powered flight.  Therefore, the buoyant force must be proportional to the absolute value of the arm position and the derivative of the arm position.  Another force that is important for the experience of flight is a force that supplies a forward motion.  Not surprisingly, we chose to call this force the forward force.  In our case the forward force is constant unless the user solid is in direct contact with another solid, in which case, the forward force is zero.  Finally, in order to have controlled flight one must be able to turn.  We calculated a turning torque that operated about the vertical axis and was proportional to the difference between the arm position from each arm.

The force-based approach worked moderately well.  Unfortunately it suffered from at least two problems that made control, and thus the user experience, frustrating.  The first problem is that with a force-based approach it takes work to overcome an opposing force.  For instance, gravity is always pulling down on the user and it takes some flapping to overcome gravity and gain an upward velocity.  No surprise there, however, the inverse is also true.  If we are applying an upward force by flapping our arms, then it takes time for gravity to overcome our upward velocity and make us fall.  The other problem is that the model does not account for any kind of centripetal force.  The very simple combination of forward force and turning torque causes a phenomenon we have dubbed, hovercrafting.  When hovercrafting the user rotates about the vertical axis to make a turn but the linear momentum of the user continues to carry them in the same direction of travel until the constant forward force restores forward flight.  The combination of these two problems made fine control of the user's position virtually impossible when tested on a task such as flying between two closely spaced blocks.

Our second, velocity based model is actually just as simplistic and ad hoc as the original force-based approach.  In fact, we used the same equations and adjusted velocities directly instead of forces.  We replaced the buoyant force with an upward velocity, the forward force with a forward velocity, and the turning torque with an angular velocity.  After tweaking the constant coefficients in the equations we were much more satisfied with our flight model.  When flying through two closely spaced boxes the user has much tighter control over their position.  The only artifact that seems very unrealistic is the upward motion due to flapping.  As it is implemented it feels a little too discontinuous.  This could probably be improved by using a simple filter or hysteresis on the upward velocity.



Graphics

All the physics simulation in the world would still not make a flight simulator.  In order for the user to become immersed in the experience they must perceive the virtual.  Of course this is done with computer graphics.  Our original goal in developing Project Icarus was to allow a person to experience a simulation of human-powered flight in an immersive environment such as a CAVE or a head mounted display (HMD).  With this in mind we used VRJuggler as the glue to bind the physics and graphics together into a portable, immersive application.  VRJuggler allows us to, "code once, experience everywhere." We can use a laptop or desktop computer to debug or fly at home, as well as use a CAVE or HMD for a truly immersive experience.

As mentioned above, we use OPAL for the physics layer.  For the graphics we use Open Scene Graph (OSG) which is an open source scene graph library.  A scene graph greatly simplifies some aspects of graphics programming.  Scene graphs take advantage of a tree-like structure to abstract concepts such as grouping and transformation.  The graph allows us to group graphical objects together and perform certain operations to the whole group easily such as tranforms, materials, switching, and lighting.  The graph also allows us to take advantage of one object in many instances, such as using one box geometry to represent all boxes.  We did not take advantage of many of these properties of the scene graph in this work mainly because they were not required and because it was a good excuse for the authors to become familiar with this particular scene graph for another project.

The environment that was created for Project Icarus is very simple.  Due to limitations in the physics engine, the scene graph library, and the authors' skill we represented all of the obstacles in the world as simple cubes on top of a ground plane.  Very simple textures were created to give the world a look similar to the 1980s movie Tron.  Each box and the ground plane has a physical representation as mentioned in preceeding paragraphs.  Using OPAL gave us collision detection and collision response for free.  Handling collisions is something that is often done in the graphics.
